====================================================================================================
Softirqs and Tasklets |
	
----------------------------------------------------------------------------------------------------
Interrupt Handling |
	I/O Interrupt Handling:
		IRQ sharing
		IRQ dynamic allocation
	
	Interrupt vectors:
	IRQ data structures:
	IRQ distribution in multiprocessor systems:
		kirqd: correct, if necessary, the automatic assignment of IRQs to CPUs
	Multiple Kernel Mode stacks:
	Saving the registers for the interrupt handler:
	Reviving a lost interrupt:
	Interrupt service routines:
	Dynamic allocation of IRQ lines
	
	Interprocessor Interrupt Handling
----------------------------------------------------------------------------------------------------
Exception Handling |
	Saving the Registers for the Exception Handler
	Entering and Leaving the Exception Handler
----------------------------------------------------------------------------------------------------
Initializing the Interrupt Descriptor Table |
Nested Execution of Exception and Interrupt Handlers |
----------------------------------------------------------------------------------------------------
Interrupts and Exceptions |
	The Intel documentation classifies interrupts and exceptions as follows:
		Interrupts: 
			Maskable interrupts
			Nonmaskable interrupts
		Exceptions: 
			Processor-detected exceptions: Faults, Traps, Aborts
			Programmed exceptions: ...handled by the control unit as traps; often called software interrupts
	
	IRQs and Interrupts:
		Programmable Interrupt Controller (PIC)
		Advanced Programmable Interrupt Controller (APIC)
		
		Interrupt requests can be distributed among the available CPUs in two ways:
			Static distribution
			Dynamic distribution
		
		interprocessor interrupts
	
	Exceptions
		Signals sent by the exception handlers

	Interrupt Descriptor Table (IDT)
		associates each interrupt or exception vector with the address of the corresponding interrupt or exception handler.
		The IDT must be properly initialized before the kernel enables interrupts
		
		three types of descriptors:
			Task Gate Descriptor, Interrupt Gate Descriptor, Trap Gate Descriptor
			
		Hardware Handling of Interrupts and Exceptions
----------------------------------------------------------------------------------------------------
The Role of Interrupt Signals |
	interrupt signals provide a way to divert the processor to code outside the normal flow of control
----------------------------------------------------------------------------------------------------
	interrupt：usually defined as an event that alters the sequence of instructions executed by a processor.
	
	synchronous interrupt：produced by the CPU control unit
							, control unit issues them only after terminating the execution of an instruction
	asynchronous interrupt：generated by other hardware devices at arbitrary times
	
	Intel microprocessor manuals designate synchronous and asynchronous interrupts as exceptions and interrupts
		synchronous interrupt -> exception
		asynchronous interrupt -> interrupt
	
	Exceptions are caused either by programming errors or by anomalous conditions that must be handled by the kernel
	Interrupts are issued by interval timers and I/O devices
CHPATER 4 Interrupts and Exceptions
====================================================================================================
Destroying Processes |
----------------------------------------------------------------------------------------------------
Creating Processes |
	The clone(  ), fork(  ), and vfork(  ) System Calls
	
	Kernel Threads
		Kernel threads run only in Kernel Mode
			, while regular processes run alternatively in Kernel Mode and in User Mode.
----------------------------------------------------------------------------------------------------
Process Switch |
	Hardware Context:
		hardware context: The set of data that must be loaded into the registers before the process resumes its execution on the CPU
		hardware context is a subset of the process execution context
		In Linux, a part of the hardware context of a process is stored in the process descriptor
			, while the remaining part is saved in the Kernel Mode stack.
		Process switching occurs only in Kernel Mode
	
	Task State Segment(TSS): * CHAPTER 2 Segmentation in Hardware
	
	Performing the Process Switch
		switch_to macro, _ _switch_to( ) function

	Saving and Loading the FPU, MMX, and XMM Registers
		...
----------------------------------------------------------------------------------------------------
Process Descriptor |
	process descriptor: a task_struct type structure whose fields contain all the information related to a single process
	
	Process State
		TASK_RUNNING:	The process is either executing on a CPU or waiting to be executed
		TASK_INTERRUPTIBLE:	The process is suspended (sleeping) until some condition becomes true
		TASK_UNINTERRUPTIBLE:	Like TASK_INTERRUPTIBLE, except that delivering a signal to the sleeping process leaves its state unchanged.
		TASK_STOPPED:	Process execution has been stopped; 
						the process enters this state after receiving a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal.
		TASK_TRACED:	Process execution has been stopped by a debugger......
		EXIT_ZOMBIE:	Process execution is terminated, but the parent process has not yet issued a wait4() or waitpid() system call to return information about the dead process
		EXIT_DEAD:		The final state: the process is being removed by the system because the parent process has just issued a wait4() or waitpid() system call for it
		
	Identifying a Process
		process descriptor pointers
		Process ID (or PID): stored in the pid field of the process descriptor
		The process list: a list that links together all existing process descriptors		

	Relationships Among Processes
		The pidhash table and chained lists
		
	How Processes Are Organized
		Wait queues: wait_queue_head_t, wait_queue_t. (doubly linked lists)
		Handling wait queues:
			initialize a new wait queue head: DECLARE_WAIT_QUEUE_HEAD(name),statically; init_waitqueue_head(),dynamically.
			initialize element: init_waitqueue_entry(q,p)
			
			all nonexclusive processes are always at the beginning of the doubly linked list and all exclusive processes are at the end, 
				the function always wakes the nonexclusive processes and then wakes one exclusive process, if any exists
		Process Resource Limits:
			
----------------------------------------------------------------------------------------------------
Processes, Lightweight Processes, and Threads |
	process: a process is an instance of a program in execution
	thread group
----------------------------------------------------------------------------------------------------
CHAPTER 3 Processes
====================================================================================================
Handling the Hardware Cache and the TLB |
	Handling the TLB
		kernel, not the hardware, that decides when a mapping between a linear and a physical address is no longer valid.

		lazy TLB mode
----------------------------------------------------------------------------------------------------
Fix-Mapped Linear Addresses |
	128 MB: kernel uses them to implement noncontiguous memory allocation and fix-mapped linear addresses

	a fix-mapped linear address is a constant linear address like 0xffffc000
		each fixmapped linear address maps one page frame of the physical memory
----------------------------------------------------------------------------------------------------
Paging in Linux |
	Linux2.6.11: a four-level paging model -> • Page Global Directory, • Page Upper Directory, • Page Middle Directory, • Page Table

	Physical Memory Layout
		physical addresses map
	Process Page Tables
	Kernel Page Tables
		master kernel Page Global Directory: kernel maintains a set of page tables for its own use, rooted at master kernel Page Global Directory
----------------------------------------------------------------------------------------------------
Paging in Hardware |
	the paging unit: translates linear addresses into physical ones
	Page Fault exception

	page: linear addresses are grouped in fixed-length intervals called pages
	page frame: The paging unit thinks of all RAM as partitioned into fixed-length page frames (sometimes referred to as physical pages)
		A page frame is a constituent of main memory, and hence it is a storage area.
	distinguish a page from a page frame:
		the former is just a block of data, which may be stored in any page frame or on disk.

	Regular Paging
		handle 4KB pages
		32 bits of a linear address: Directory Table Offset
		Page Directory
		Page Table

	Extended Paging
		handle 4MB pages
		Extended paging coexists with regular paging

	Hardware Protection Scheme
		2 levels, controlled by the User/Supervisor flag
		only two types of access rights (Read and Write), no Execute

	An Example of Regular Paging

	Physical Address Extension (PAE)
		Page Directory Pointer Table (PDPT)
		a process running in User Mode cannot use a physical address space larger than 4 GB.
		PAE allows the kernel to exploit up to 64 GB of RAM,
			and thus to increase significantly the number of processes in the system

	Paging for 64-bit Architectures
		Linux: providing a common paging model that fits most of the supported hardware paging systems

	Hardware cache
		to reduce the speed mismatch between CPU and RAM.
			to speed up getting/writing data from/to RAM (by lp)
		locality principle
			holds both for programs and data structures.
			This states that because of the cyclic structure of programs and the packing of related data into linear arrays,
				addresses close to the ones most recently used have a high probability of being used in the near future
		cache snooping

	Translation Lookaside Buffers (TLB)
		to speed up linear address translation
----------------------------------------------------------------------------------------------------
Segmentation in Linux |
	user code segment and user data segment
	kernel code segment and kernel data segment
	Segment Selectors are defined by the macros _ _USER_CS, _ _USER_DS, _ _KERNEL_CS, and _ _KERNEL_DS,

	The Linux GDT
		one GDT for every CPU in the system, store identical entries, except for a few cases......
	The Linux LDTs
		Call gates are a mechanism provided by 80 × 86 microprocessors
			to change the privilege level of the CPU while invoking a predefined function
----------------------------------------------------------------------------------------------------
Segmentation in Hardware |
	two different address translation ways: real mode; protected mode

	segment, segmentation, Segment Selectors, Segmentation Registers

	A logical address consists of two parts:
		a segment identifier(Segment Selector, 16-bits),
		an offset(32-bits) that specifies the relative address within the segment
	segmentation registers: to hold Segment Selectors, to retrieve segment selectors quickly
		cs, ss, ds, es, fs, and gs
	cs register: another function, includes a 2-bit field that specifies the Current Privilege Level (CPL) of the CPU
		0, the highest; 3, the lowest
		Linux uses only levels 0 and 3, called Kernel Mode and User Mode.

	8-byte Segment Descriptor: represent segment, describes the segment characteristics
		stored in the Global Descriptor Table (GDT) or in the Local Descriptor Table (LDT)
			Usually only one GDT is defined
				gdtr control register: contain the address and size of the GDT in main memory
			each process is permitted to have its own LDT if it needs to create additional segments besides those stored in the GDT
				ldtr control register: contain the address and size of the currently used LDT

	DPL - Descriptor Privilege Level

	Code Segment Descriptor
	Data Segment Descriptor
	Task State Segment Descriptor (TSSD): refers to a Task State Segment (TSS), a segment used to save the contents of the processor registers
		appear only in the GDT
	Local Descriptor Table Descriptor (LDTD): appear only in the GDT
----------------------------------------------------------------------------------------------------
Memory Addresses |
	Logical address
	Linear address (also known as virtual address)
	Physical address

	memory cell: A single 32-bit unsigned integer that can be used to address up to 4 GB—that is, up to 4,294,967,296 memory cells.

	Memory Management Unit (MMU)
		transform a logical address into a linear address by means of a hardware circuit called a segmentation unit;
		subsequently, a second hardware circuit called a paging unit transforms the linear address into a physical address

		Logical address -> SEGMENTATION UNIT -> Linear address -> PAGING UNIT -> Physical address

	a memory arbiter: a hardware circuit, inserted between the bus and every RAM chip
		to grant access to a CPU if the chip is free and to delay it if the chip is busy servicing a request by another processor

	Direct Memory Access (DMA)
----------------------------------------------------------------------------------------------------
CHAPTER 2 Memory Addressing
====================================================================================================
Device Drivers |
	device drivers
----------------------------------------------------------------------------------------------------
Memory Management |
	virtual memory
		virtual address space
		Page Table：specify how virtual addresses correspond to physical addresses

	Random access memory(RAM) usage
		storing the kernel image (i.e., the kernel code and the kernel static data structures)
		handled by the virtual memory system and is used in three possible ways
			......

	Kernel Memory Allocator (KMA)
		a subsystem that tries to satisfy the requests for memory areas from all parts of the system
			other kernel subsystems needing memory for kernel use
			system calls from user programs to increase their processes’ address spaces

	Process virtual address space handling
		memory area descriptors
		demand paging: a memory allocation strategy
		Copy On Write strategy

	Caching
----------------------------------------------------------------------------------------------------
Process groups and login sessions |
	process groups: represent a “job” abstraction
	Each process descriptor includes a field containing the process group ID.
	a group leader, which is the process whose PID coincides with the process group ID.
		A newly created process is initially inserted into the process group of its parent.

	login sessions：
	A login session may have several process groups active simultaneously
		one is always in the foreground, which means that it has access to the terminal.
		The others are in the background.

	When a background process tries to access the terminal, it receives a SIGTTIN or SIGTTOUT signal.
		commands bg and fg can be used to put a process group in either the background or the foreground.
----------------------------------------------------------------------------------------------------
Zombie processes |
	zombie process: represent terminated processes:
		a process remains in that state until its parent process executes a wait4( ) system call on it.
	The system call handler extracts data about resource usage from the process descriptor fields;
		the process descriptor may be released once the data is collected.

	一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，
	而是留下一个称为僵尸进程（Zombie）的数据结构。（exit作用是使进程退出，仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）

	Unix提供了一种机制可以使父进程知道子进程结束时的状态信息
	机制: 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。
			但仍保留一定的信息（包括进程号PID，退出状态，运行时间等）。直到父进程通过wait/waitpid来取时才释放。
	僵尸进程的危害：如果进程不调用wait/waitpid的话，那么保留的信息就不会释放，其进程号就会一直被占用；
			但系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

	When a process terminates, the kernel makes all the existing children of the terminated process become children of init.
	init will execute wait()-like function.
	So the existing children of the terminated process will not become zombie processes.
----------------------------------------------------------------------------------------------------
Process Management |
	fork( ): create a process
		require both the parent’s data and the parent’s code to be duplicated and the copies assigned to the child.
	exec()-like: load a new program
	_exit( ): terminate a process
		The kernel handles this system call by releasing the resources owned by the process
		and sending the parent process a SIGCHLD signal, which is ignored by default
----------------------------------------------------------------------------------------------------
Signals and Interprocess Communication |
	a process may react to a signal delivery in two possible ways:
		• Ignore the signal.
		• Asynchronously execute a specified procedure (the signal handler).

	kernel performs a default action that depends on the signal number. The five possible default actions are:
		• Terminate the process.
		• Write the execution context and the contents of the address space in a file (core dump) and terminate the process.
		• Ignore the signal.
		• Suspend the process.
		• Resume the process’s execution, if it was stopped.

	SIGKILL and SIGSTOP signals cannot be directly handled by the process or ignored.

	other kinds of interprocess communication among processes in User Mode
		• semaphores, message queues, and shared memory
		--semget( ), msgget( ), shmget( )

	Shared memory
		shmget( ), shmat( ), shmdt( )
----------------------------------------------------------------------------------------------------
The Process/Kernel Model |
	User Mode
	Kernel Mode

	kernel threads:
	reentrant functions: functions that they modify only local variables and do not alter global data structures.
	reentrant kernel: not limited only to such reentrant functions
					  can include nonreentrant functions and use locking mechanisms to ensure that
							only one process can execute a nonreentrant function at a time.
	kernel control path: denotes the sequence of instructions executed by the kernel
							to handle a system call, an exception, or an interrupt
----------------------------------------------------------------------------------------------------
Processes |
	In traditional operating systems, a process executes a single sequence of instructions in an address space;
		the address space is the set of memory addresses that the process is allowed to reference.
	Modern operating systems allow processes with multiple execution flows
		that is, multiple sequences of instructions executed in the same address space.
----------------------------------------------------------------------------------------------------
Multiuser Systems |
	Multiuser operating systems must include several features:
		• An authentication mechanism for verifying the user’s identity
		• A protection mechanism against buggy user programs that could block other applications running in the system
		• A protection mechanism against malicious user programs that could interfere with or spy on the activity of other users
		• An accounting mechanism that limits the amount of resource units assigned to each user
----------------------------------------------------------------------------------------------------
Basic Operating System Concepts |
	The operating system must fulfill two main objectives:
		• Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform.
		• Provide an execution environment to the applications that run on the computer system (the so-called user programs).

	two different execution modes for the CPU:
		a nonprivileged mode for user programs
		a privileged mode for the kernel.
	Unix calls these User Mode and Kernel Mode,
----------------------------------------------------------------------------------------------------
CHAPTER 1 Introduction
====================================================================================================
Understanding the Linux Kernel
====================================================================================================