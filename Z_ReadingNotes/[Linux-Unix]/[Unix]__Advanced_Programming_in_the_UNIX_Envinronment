Over
====================================================================================================
----------------------------------------------------------------------------------------------------
Chapter 21. Communicating with a Network Printer
====================================================================================================
----------------------------------------------------------------------------------------------------
Chapter 20. A Database Library
====================================================================================================
19.3 Opening Pseudo-Terminal Devices |
19.2 Overview |
----------------------------------------------------------------------------------------------------
Chapter 19. Pseudo Terminals
====================================================================================================
18.13 termcap, terminfo, and curses |
	termcap & terminfo:
		What they do provide is a way to perform typical operations (clear the screen, move the cursor) on a wide variety of terminals.
		
	curse:
		curses does help with some of the details that we’ve addressed in this chapter
		like, set raw mode, set cbreak mode, turn echo on and off
----------------------------------------------------------------------------------------------------
18.12 Terminal Window Size |
	Most UNIX systems provide a way to keep track of the current terminal window size and to have the kernel notify the foreground process group when the size changes. 
	The kernel maintains a winsize structure for every terminal and pseudo terminal.
	
	This feature is provided to notify applications (such as the vi editor) when the window size changes. 
	When it receives the signal, the application can fetch the new size and redraw the screen.
	
	struct winsize size;
	ioctl(fd, TIOCGWINSZ, (char *) &size); // TIOCSWINSZ
----------------------------------------------------------------------------------------------------
18.11 Noncanonical Mode |
	Noncanonical mode is specified by turning off the ICANON flag in the c_lflag field of the termios structure
	In noncanonical mode, the input data is not assembled into lines
----------------------------------------------------------------------------------------------------
18.10 Canonical Mode |
18.9 Terminal Identification |
18.8 Line Control Functions |
----------------------------------------------------------------------------------------------------
18.7 Baud Rate Functions |
	baud rate: refers to ‘bits persecond’
	
	get/set input/output baud rates
----------------------------------------------------------------------------------------------------
18.6 stty Command |
	we can use tcgetattr & tcsetattr function to examine & change the terminal options
	or
	use stty command:
		stty -a # display all the options
----------------------------------------------------------------------------------------------------
18.5 Terminal Option Flags |
	describe Terminal Option Flags in details
----------------------------------------------------------------------------------------------------
18.3 Special Input Characters |
	Summary of special terminal input characters
	
	describe special terminal input characters in details
----------------------------------------------------------------------------------------------------
18.2 Overview |
	Terminal I/O has two modes:
		1. Canonical mode input processing. 
			In this mode, terminal input is processed as lines. The terminal driver returns at most one line per read request.
		2. Noncanonical mode input processing. 
			The input characters are not assembled into lines.
			
	Programs that manipulate the entire screen, such as the vi editor, use noncanonical mode
	
	terminal line discipline
	
	how to examine and change terminal device characteristics:
		termios structure & flags
		functions
----------------------------------------------------------------------------------------------------
Chapter 18 Terminal I/O
====================================================================================================
17.6 An Open Server, Version 2 |
	getopt function: process command arguments
----------------------------------------------------------------------------------------------------
17.2 UNIX Domain Sockets |
	UNIX domain sockets are used to communicate with processes running on the same machine.
	
	The UNIX domain datagram service is reliable
----------------------------------------------------------------------------------------------------
	the UNIX domain socket mechanism
Chapter 17 Advanced IPC
====================================================================================================
16.8 Nonblocking and Asynchronous I/O
----------------------------------------------------------------------------------------------------
16.7 Out-of-Band Data |
	Out-of-band data is an optional feature supported by some communication protocols, allowing higher-priority delivery of data than normal. 
	Out-of-band data is sent ahead of any data that is already queued for transmission. 
	TCP supports out-of-band data, but UDP doesn’t.
----------------------------------------------------------------------------------------------------
16.6 Socket Options
16.5 Data Transfer 
16.4 Connection Establishment
----------------------------------------------------------------------------------------------------
16.3 Addressing |
	Identifying the process has two components:
		The machine’s network address helps us identify the computer on the network we wish to contact
		the service, represented by a port number, helps us identify the particular process on the computer
	
	16.3.1 Byte Ordering
		The byte order is a characteristic of the processor architecture
			, dictating how bytes are ordered within larger data types, such as integers
			
		The TCP/IP protocol suite uses big-endian byte order.
	
	16.3.2 Address Formats
	16.3.3 Address Lookup
		DNS (Domain Name System)
		NIS (Network Information Service)
		Services are represented by the port number portion of the address. Each service is offered on a unique, well-known port number.
	16.3.4 Associating Addresses with Sockets
----------------------------------------------------------------------------------------------------
Chapter 16 Network IPC: Sockets
====================================================================================================
15.9 Shared Memory |
----------------------------------------------------------------------------------------------------
15.8 Semaphores |
	A semaphore is a counter used to provide access to a shared data object for multiple processes
----------------------------------------------------------------------------------------------------
15.7 Message Queues |
	A message queue is a linked list of messages stored within the kernel and identified by a message queue identifier.
	
	msgget msgsnd msgrcv
	We don’t have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field
	
	msgsnd: The ptr argument points to a long integer that contains the positive integer message type
		, and it is immediately followed by the message data.
----------------------------------------------------------------------------------------------------
15.6 XSI IPC |
	XSI IPC: message queues, semaphores, shared memory
	
	15.6.1 Identifiers and Keys
	15.6.2 Permission Structure
	15.6.3 Configuration Limits
	15.6.4 Advantages and Disadvantages
----------------------------------------------------------------------------------------------------
15.5 FIFOs |
	mkfifo mkfifoat
	With FIFOs, unrelated processes can exchange data
	
	As with a pipe, if we write to a FIFO that no process has open for reading, the signal SIGPIPE is generated
		When the last writer for a FIFO closes the FIFO, an end of file is generated for the reader of the FIFO
	As with pipes, the constant PIPE_BUF specifies the maximum amount of data that can be written atomically to a FIFO.
----------------------------------------------------------------------------------------------------
15.4 Coprocesses |
	A UNIX system filter is a program that reads from standard input and writes to standard output.
	
	A filter becomes a coprocess when the same program generates the filter’s input and reads the filter ’s output
	
	using pipe
----------------------------------------------------------------------------------------------------
15.3 popen and pclose Functions |
	popen pclose

	The shell command ${PAGER:-more} says to use the value of the shell variable PAGER
		if it is defined and non-null; otherwise, use the string more.
----------------------------------------------------------------------------------------------------
15.2 Pipes |
	Pipes have two limitations:
		1. Historically, they have been half duplex (i.e., data flows in only one direction)
			Some systems now provide full-duplex pipes
		2. Pipes can be used only between processes that have a common ancestor.
			Normally, a pipe is created by a process, that process calls fork, and the pipe is used between the parent and the child
			
	FIFO get around the second limitation
	Sockets get around both limitations
	
	int pipe(int fd[2]);
		fd[0] is open for reading, and fd[1] is open for writing
----------------------------------------------------------------------------------------------------
	interprocess communication (IPC)
Chapter 15 Interprocess Communication
====================================================================================================
14.8 Memory-Mapped I/O
	call fstat to obtain the size of the input file
	mmap msync munmap
----------------------------------------------------------------------------------------------------
14.6 readv and writev Functions
	The readv and writev functions let us read into and write from multiple noncontiguous buffers in a single function call. 
		These operations are called scatter read and gather write.
----------------------------------------------------------------------------------------------------
14.5 Asynchronous I/O
	14.5.3 POSIX Asynchronous I/O
----------------------------------------------------------------------------------------------------
14.4 I/O Multiplexing |
	14.4.1 select and pselect Functions
	14.4.2 poll Function
----------------------------------------------------------------------------------------------------
14.3 Record Locking | 
	Record locking is the term normally used to describe the ability of a process 
		to prevent other processes from modifying a region of a file while the first process is reading or modifying that portion of the file.
	
	A better term is byte-range locking, given that it is a range of a file (possibly the entire file) that is locked
	
	Implied Inheritance and Release of Locks
		1. whenever a descriptor is closed, any locks on the file referenced by that descriptor for that process are released
		2. Locks are never inherited by the child across a fork
		3. Locks are inherited by a new program across an exec
			if the close-on-exec flag is set for a file descriptor
				, all locks for the underlying file are released when the descriptor is closed as part of an exec
	
	Advisory versus Mandatory Locking
		advisory locking: to functions (interfaces), other process not using these functions may also access related file or database (by braden)
		mandatory locking: to file or a database (by braden)
----------------------------------------------------------------------------------------------------
14.2 Nonblocking I/O |
----------------------------------------------------------------------------------------------------
CHAPTER 14 Advanced I/O
====================================================================================================
13.7 Client–Server Model |
	close-on-exec flag
----------------------------------------------------------------------------------------------------
13.6 Daemon Conventions |
13.5 Single-Instance Daemons |
----------------------------------------------------------------------------------------------------
13.4 Error Logging |
	syslogd
	
	openlog syslog setlogmask
----------------------------------------------------------------------------------------------------
13.3 Coding Rules |
	Some basic rules to coding a daemon prevent unwanted interactions from happening & examples
----------------------------------------------------------------------------------------------------
13.2 Daemon Characteristics |
	Anything with a parent process ID of 0 is usually a kernel process started as part of the system bootstrap procedure.
		(except init, which is a user-level command started by the kernel at boot time.))
	
	This version of Linux uses a special kernel process, kthreadd, to create other kernel processes
		, so kthreadd appears as the parent of the other kernel daemons
	
	Process 1 is usually init (launchd on Mac OS X)
	
	most of the daemons run with superuser (root) privileges
	None of the daemons has a controlling terminal: the terminal name is set to a question mark.
	the parent of the user-level daemons is the init process
----------------------------------------------------------------------------------------------------
CHAPTER 13 Daemon Processes
====================================================================================================
12.10 Threads and I/O
	pread
	pwrite
----------------------------------------------------------------------------------------------------
12.9 Threads and fork
	Inside the child process, only one thread exists. It is made from a copy of the thread that called fork in the parent
	
	clean up the lock state
	clean up the condition variable
----------------------------------------------------------------------------------------------------
12.8 Threads and Signals
	Each thread has its own signal mask, but the signal disposition is shared by all threads in the process
----------------------------------------------------------------------------------------------------
12.7 Cancel Options
	cancelability state:
			a call to pthread_cancel doesn’t wait for a thread to terminate
			a thread will continue to execute after a cancellation request is made until the thread reaches a cancellation point
			A cancellation point is a place where the thread checks whether it has been canceled
				, and if so, acts on the request
				
			sometime you may need to call pthread_testcancel to add your own cancellation points to the program
		PTHREAD_CANCEL_ENABLE(default)
		PTHREAD_CANCEL_DISABLE
	
	cancelability type:
		defered cancellation(default)
		asynchronous cancellation
----------------------------------------------------------------------------------------------------
12.6 Thread-Specific Data
----------------------------------------------------------------------------------------------------
12.5 Reentrancy
	thread-safe: a function is reentrant with respect to multiple threads
	async-signal safe: a function that is safe to be reentered from an asynchronous signal handler
----------------------------------------------------------------------------------------------------
12.4 Synchronization Attributes
	12.4.1 Mutex Attributes
		process-shared: If the process-shared mutex attribute is set to PTHREAD_PROCESS_SHARED
			, a mutex allocated from a memory extent shared between multiple processes may be used for synchronization by those processes
		robust: related to mutexes that are shared among multiple processes.
			PTHREAD_MUTEX_ROBUST: This value will cause a thread blocked in a call to pthread_mutex_lock to acquire the lock 
				when another process holding the lock terminates without first unlocking it
		type: PTHREAD_MUTEX_NORMAL/ERRORCHECK/RECURSIVE/DEFAULT
		
	12.4.2 Reader–Writer Lock Attributes
		process-shared
		
	12.4.3 Condition Variable Attributes
		process-shared
		clock: controls which clock is used when evaluating the timeout argument (tsptr) of the pthread_cond_timedwait function.
	
	12.4.4 Barrier Attributes
		process-shared
----------------------------------------------------------------------------------------------------
12.3 Thread Attributes |
	detachstate: detached thread attribute
	guardsize: guard buffer size in bytes at end of thread stack
	stackaddr: lowest address of thread stack
	stacksize: minimum size in bytes of thread stack
----------------------------------------------------------------------------------------------------
	look at thread attributes and synchronization primitive attributes
Chapter 12 Thread Control
====================================================================================================
11.6 Thread Synchronization |
	11.6.1 Mutexes:
		mutual-exclusion -> mutex

	11.6.2 Deadlock Avoidance
		Deadlocks can be avoided by carefully controlling the order in which mutexes are locked.
		Sometimes, an application’s architecture makes it difficult to apply a lock ordering
		
	11.6.3 pthread_mutex_timedlock Function
		allows us to bound the time that a thread blocks when a mutex it is trying to acquire is already locked
		The timeout specifies how long we are willing to wait in terms of absolute time
	
	11.6.4 Reader–Writer Locks
		Reader–writer locks are also called shared–exclusive locks. When a reader–writer
			lock is read locked, it is said to be locked in shared mode. When it is write locked, it is
			said to be locked in exclusive mode
	
	11.6.6 Condition Variables
		another synchronization mechanism available to threads
		
	11.6.7 Spin Locks
		
	11.6.8 Barriers
		Barriers are a synchronization mechanism that can be used to coordinate multiple
			threads working in parallel. A barrier allows each thread to wait until all cooperating
			threads have reached the same point, and then continue executing from there.
----------------------------------------------------------------------------------------------------
11.5 Thread Termination |
	A single thread can exit in 3 ways:
		1. return from start function
		2. be canceled by another thread in the same process: int pthread_cancel(pthread_t tid);
			pthread_cancel doesn’t wait for the thread to terminate; it merely makes the request
		3. call pthread_exit function

	int pthread_join(pthread_t thread, void **rval_ptr);
		The calling thread will block until the specified thread 
			calls pthread_exit, returns from its start routine, or is canceled
			
	thread cleanup handlers: arrange for functions to be called when it exits
			pthread_cleanup_push pthread_cleanup_pop
		More than one cleanup handler can be established for a thread
		if the thread terminates by returning from its start routine, its cleanup handlers are not called,
		he cleanup handlers are called in the reverse order from which they were installed
	
	int pthread_detach(pthread_t tid);
----------------------------------------------------------------------------------------------------
11.4 Thread Creation |
	pthread_create
----------------------------------------------------------------------------------------------------
11.3 Thread Identification |
	pthread_equal	pthread_self
----------------------------------------------------------------------------------------------------
11.2 Thread Concepts |
----------------------------------------------------------------------------------------------------
Chapter 11 Threads
====================================================================================================
10.22 Signal Names and Numbers |
10.21 Job-Control Signals |
10.17~20 abort system sleepS sigqueue Function |
----------------------------------------------------------------------------------------------------
10.16 sigsuspend Function |
	the process is suspended until a signal is caught or until a signal occurs that terminates the process
----------------------------------------------------------------------------------------------------
10.15 sigsetjmp and siglongjmp Functions |
	when a signal handler is invoked, the signal being caught is added to the current signal mask of the process.
----------------------------------------------------------------------------------------------------
10.14 sigaction Function |
	to examine or modify (or both) the action associated with a particular signal
	using sigaction to implement signal
----------------------------------------------------------------------------------------------------
10.13 sigpending Function |
	returns the set of signals that are blocked from delivery and currently pending for the calling process.
----------------------------------------------------------------------------------------------------
10.12 sigprocmask Function |
	signal mask of a process is the set of signals currently blocked from delivery to that process.
	SIGKILL and SIGSTOP can’t be blocked
----------------------------------------------------------------------------------------------------
10.8 kill and raise Funtions |
	kill: send a signal to a process or a group of process
		eg. kill(getpid(), signo): send signo to itself
	raise: send signo to itself
	kill by signo 0: check the process if exists
		may not the process you think for check pid, not atomic
----------------------------------------------------------------------------------------------------
Chapter 10 Signals
====================================================================================================
Advanced Programming in the UNIX Envinronment
====================================================================================================